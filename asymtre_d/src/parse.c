/*---------------------------------------------------------------------
 
	parse.c -- Parse configuration files, such as robot.cfg and
			   commonsense.cfg.

	Fang Tang
--------------------------------------------------------------------- */

#include <reason.h>
#include <parse.h>

/*
 * de_comment
 * delete all the comments from .cfg and write to a "simple"
 */
void de_comment(IS is, int id)
{
  FILE *tmp;
  char fn[20];
  int i, flag = 0;

  if (id == 0)
    sprintf(fn, "simple");
  else sprintf(fn, "simple%d", id);
  tmp = fopen(fn, "w");
  if (tmp == NULL) {
    perror("simple");
    exit(1);
  }

  while (get_line(is) >= 0) {
    for (i = 0; i < strlen(is->text1); i++) {
      if (is->text1[i] == '#') {
        flag = 1;
        if (i == 0)
          fprintf(tmp, " \n");
          break;
        } else {
          if ((i == 0) && (is->text1[i]) == '\n')
            fprintf(tmp, " \n");
          else if ((is->text1[i] != ',') && (is->text1[i] != '{') && (is->text1[i] != '}') && (is->text1[i] != '=')) {
               if ((is->text1[i] == '[') || (is->text1[i] == ']') || (is->text1[i] == '|') || (is->text1[i] == '&'))
                 fprintf(tmp, " %c ", is->text1[i]);
               else
                 fprintf(tmp, "%c", is->text1[i]);
               }
      }
    }
    if (flag == 1) {
      flag = 0;
      continue;
    }
  }
  fclose(tmp);
  return;
}

/*
 * get_list
 * divide the file into a dlist
 */
Dllist get_list(IS robot, int *count)
{
  Dllist list;
  Node *n;
  int i, tmp;

  list = new_dllist();
  while (get_line(robot) >= 0) {
    for (i = 0; i < robot->NF; i++) {
      n = (Node *) malloc(sizeof(Node));
      n->line = robot->line;

      if (sscanf(robot->fields[i], "%d", &tmp) == 1) {
        n->num = tmp;
        n->s = 0;
      } else {
        n->num = -1;
        n->s = strdup(robot->fields[i]);
				if ((strcmp(n->s, "[") == 0) || (strcmp(n->s, "]") == 0) || (strcmp(n->s, "|") == 0) || (strcmp(n->s, "&") == 0))
					n->line--;
          count += strlen(n->s);
        }
      dll_append(list, new_jval_v((void *)n));
    }
  }
  return list;
}

/*
 * invalid_sensor
 * return 1 if it's invalid
 */
int invalid_sensor(char *s)
{
  int i;
  for (i = 0; i < NS && SENSOR[i] != 0; i++)
    if (strcmp(SENSOR[i], s) == 0)
      return 0;
  return 1;
}

/*
 * invalid_atomic
 * return 1 if it's not a valid atomic behavior
 */
int invalid_atomic(char *s)
{
  int i;
  for (i = 0; i < NA && ATOMIC[i] != 0; i++)
    if (strcmp(ATOMIC[i], s) == 0)
      return 0;
  return 1;
}

/*
 * invalid_composite
 * return 1 if it's not a valid composite behavior
 */
int invalid_composite(char *s)
{
  int i;
  for (i = 0; i < NC && COMPOSITE[i] != 0; i++)
    if (strcmp(COMPOSITE[i], s) == 0)
      return 0;
  return 1;
}

/*
 * invalid_info
 * return 1 if it's invalid
 */
int invalid_info(char *s)
{
  int i;
  for (i = 0; i < NI && INFO[i] != 0; i++)
    if (strcmp(INFO[i], s) == 0)
      return 0;
  return 1;
}
	

/*
 * get_robot
 * reading from the inputfile and fill in the Robot struct
 */
Dllist get_robot(Robot *r, Dllist list, int count, int id)
{
  int i;
  Node *n;
  Dllist ptr;	

  /* There are two fields, first is ID, then the number of sensors */
  for (i = 0; i < 1; i++) { // instead of i < 2, one field now
    ptr = dll_first(list);
    n = (Node *) jval_v(dll_val(ptr));
    dll_delete_node(ptr);
    if (n->num < 0) {
      //if (i == 0)
        //printf("At line %d in robot.cfg, robot ID should be >= 0\n", n->line);
      //else 
      printf("At line %d in robot.cfg, number of sensors should be >= 0\n", n->line);
      exit(1);
    }else if (n->num == 0) {
     return ptr;
    } else {
      r->num = n->num;
    }
  }
  /* get the sensor list */
  for (i = 0; i < r->num; i++) {
    if (dll_empty(list)) {
      printf("At line %d in robot.cfg, wrong number of sensors: %d\n", n->line, i+1);
      exit(1);
    }
    ptr = dll_first(list);
    n = (Node *) jval_v(dll_val(ptr));
    dll_delete_node(ptr);
    if (n->num < 0) {
      if (invalid_sensor(n->s)) {
        printf("Invalid sensor type %s at line %d in robot.cfg\n", n->s, n->line);
        exit(1);
      }	
      dll_append(r->sensors, new_jval_s(n->s));
    }
    else {
      printf("At line %d in robot.cfg, wrong sensor type\n", n->line);
      exit(1);
    }
  }
  free(n);
  return ptr;
}

/*
 * Find the types of information that can be generated by local robot
 */

/*
 * new_robot
 */
void new_robot(int id)
{
  int i;

  /* allocate the Robot structure */
  local = (Robot *) malloc(sizeof(Robot));
  if (local == 0) {
    perror("malloc: local robot");
    exit(1);
  }

  /* initialization */
  local->rid = id;
  local->num = 0;
  local->sensors = new_dllist();
  local->behaviors = new_dllist();

  local->maxhelpers = 0;
  local->maxsubgroup = 1;
  local->numhelpers = 0;

  local->infolist = new_dllist();

  local->solutionlist = new_dllist();
  local->s_i = 0;
  local->best_i = -1;

  local->capable = 0;
  local->help = 0;
  local->currh = 0;

  local->activeB = new_dllist();
  local->activeS = new_dllist();

  local->lock = (pthread_mutex_t *) malloc(sizeof(pthread_mutex_t));
  pthread_mutex_init(local->lock, NULL);

}

/*
 * robot_cfg
 * robot configuration
 */
int robot_cfg(IS is, int id)
{
  int i, tmp, count = 0;
  IS robot;
  Robot *r;
  Dllist list, ptr;
  char fn[20];
  //Node *tmpn;

  /* delete comment */
  de_comment(is, id);

  /* read in the new input conf. file */
  sprintf(fn, "simple%d", id);
  robot = new_inputstruct(fn);
  if (robot == 0) {
    perror("simple");
    exit(1);
  }

  /* get list of inputs */
  list = get_list(robot, &count);

  // parse, and fill in the data structure
  get_robot(local, list, count, id);	

  free_dllist(list);
  //free(tmpn);
  jettison_inputstruct(robot);
  return 1;
}


/*
 * get_atomic
 * parse atomic behaviors, return
 */
void get_atomic(Dllist list)
{
  Atomic *a;
  Dllist ptr;
  Node *tmp;
  float prob;

  ptr = dll_first(list);
  dll_delete_node(ptr);

  /* allocate the struct for atomic behaviors */
  Alist = (Behaviors *) malloc(sizeof(Behaviors));
  Alist->behaviors = new_dllist();

  /* parse atomic behaviors */
  ptr = dll_first(list);
  while (ptr != list) {
    tmp = (Node *) jval_v(dll_val(ptr));
    a = (Atomic *) malloc(sizeof(Atomic));

    if (tmp->num > 0) {
      printf("1. Wrong format at line %d, \n", tmp->line);
      exit(1);
    }
    if ((strcmp(tmp->s, "composite") == 0) || (strcmp(tmp->s, "cost") == 0))
      break;
    if (invalid_atomic(tmp->s)) {
      printf("Invalid atomic behavior type at line %d\n", tmp->line);
      exit(1);
    }
    a->name = strdup(tmp->s);
    dll_delete_node(ptr);

    ptr = dll_first(list);
    if (ptr == list) {
      printf("Wrong format \n");
      exit(1);
    }
    tmp = (Node *) jval_v(dll_val(ptr));
    if (tmp->num > 0) {
      printf("2. Wrong format at line %d\n", tmp->line);
      exit(1);
    }
    if (strcmp(tmp->s, "&") != 0) {
      printf("3. Wrong format at line %d\n", tmp->line);
      exit(1);
    }
    dll_delete_node(ptr);

    ptr = dll_first(list);
    if (ptr == list) {
      printf("Wrong format \n");
      exit(1);
    }
    tmp = (Node *) jval_v(dll_val(ptr));
    if (tmp->num > 0) {
      printf("4. Wrong format at line %d\n", tmp->line);
      exit(1);
    }
    if (invalid_sensor(tmp->s)) {
      printf("5. Wrong format at line %d, %s\n", tmp->line, tmp->s);
      exit(1);
    }
    a->sensor = strdup(tmp->s);
    dll_delete_node(ptr);

    ptr = dll_first(list);
    if (ptr == list) {
      printf("Wrong format \n");
      exit(1);
    }
    tmp = (Node *) jval_v(dll_val(ptr));
    if (tmp->num < 0) {
      printf("6. Wrong format at line %d\n", tmp->line);
      exit(1);
    }
    a->prob = (float)tmp->num/100;
    dll_delete_node(ptr);
    ptr = dll_first(list);

    dll_append(Alist->behaviors, new_jval_v(a));
  }
}

/*
 * get_composite
 * parse composite behaviors, return
 */
void get_composite(Dllist list)
{
	Composite *com;
	Atomic *atom;
	Node *tmp;
	Dllist ptr;
	int type = 0, update = 0, count = 0, i = 0, cond = 0;
	int num = 0;

	//printf("----------------------get_composite--------------------\n");

	ptr = dll_first(list);
	dll_delete_node(ptr);

	/* allocate the struct for composite behaviors */
	Clist = (Behaviors *) malloc(sizeof(Behaviors));
	Clist->num = -1;
	Clist->behaviors = new_dllist();

	/* Get the number of composite behaviors */
	ptr = dll_first(list);
	if (ptr != list) {
		tmp = (Node *) jval_v(dll_val(ptr));
		if (tmp->num < 0) {
			if ((strcmp(tmp->s, "atomic") == 0) || (strcmp(tmp->s, "cost") == 0))	
				return;
			printf("At line %d in commonsense.cfg, it should give the number of composite behaviors.\n", tmp->line); 
			exit(1);
		} else {
			Clist->num = tmp->num;
			//printf("number of behaviors: %d\n", Clist->num);	
			dll_delete_node(ptr);
		}
	} else return;

	/* get composite behaviors and their dependencies */
	ptr = dll_first(list);
	while (ptr != list) {
		tmp = (Node *) jval_v(dll_val(ptr));
		com = (Composite *)malloc(sizeof(Composite));
		com->num = -1;
		com->blist = new_dllist();

		if (tmp->num > 0) {
			printf("7. Wrong format at line %d\n", tmp->line);
			exit(1);
		}
		if ((strcmp(tmp->s, "atomic") == 0) || (strcmp(tmp->s, "cost") == 0))
			break;
		if (invalid_composite(tmp->s)) {
			printf("Invalid composite behavior type at line %d : %s\n", tmp->line, tmp->s);
			exit(1);
		}
		count++;
		if (count > Clist->num) {
			dll_delete_node(ptr);
			break;
		}	
		com->name = strdup(tmp->s);
		//printf("%d. %s\n", count, com->name);
		dll_delete_node(ptr);

		/* get the number of ways to implement certain composite behavior */
		ptr = dll_first(list);
		if (ptr != list) {
			tmp = (Node *) jval_v(dll_val(ptr));
			if (tmp->num < 0) {
				if ((strcmp(tmp->s, "composite") == 0) || (strcmp(tmp->s, "cost") == 0))
					return;
				printf("At line %d in commonsense.cfg, it should give the number of atomic behaviors.\n", tmp->line);
				exit(1);
			} else {
				com->num = tmp->num;
				dll_delete_node(ptr);
			}
		} else return;

		/* get the atomic behaviors */
		i = 0; num = 0;
		while (i <= com->num) {
			ptr = dll_first(list);
			if (ptr == list)
				break;
			tmp = (Node *) jval_v(dll_val(ptr));	
			if (tmp->num > 0) {
				printf("Wrong format of atomic behavior at line %d\n", tmp->line);
				exit(1);
			}
			if ((strcmp(tmp->s, "atomic") == 0) || (strcmp(tmp->s, "cost") == 0)) 
				break;
			if (!invalid_composite(tmp->s) && (i == com->num))
				break;
			if (strcmp(tmp->s, "|") == 0) {
				update = 1; cond = 1; num = 0;
			}
			if (strcmp(tmp->s, "[") == 0) {
				num++;
				type = num; cond = 1;
			}
			if (strcmp(tmp->s, "]") == 0) {
				type = 0; cond = 1;
			}
			if (strcmp(tmp->s, "&") == 0) {
				cond = 1; i--;
			}
			if (cond == 1) {
				dll_delete_node(ptr);
				cond = 0;
				continue;
			}
			if (invalid_atomic(tmp->s) && invalid_composite(tmp->s) && invalid_info(tmp->s)) {
				printf("Invalid atomic behavior type: %s at line %d\n", tmp->s, tmp->line); 
				exit(1);
			}
			atom = (Atomic *) malloc(sizeof(Atomic));
			atom->type = type;
			atom->way = i;	
			atom->name = strdup(tmp->s);
			dll_append(com->blist, new_jval_v(atom));
			dll_delete_node(ptr);
			//printf("%d: type=%d, %s\n", i, atom->type, tmp->s);
      dll_append(hashway[i], new_jval_v(atom));
      i++;
		}
		//printf("\n");
		dll_append(Clist->behaviors, new_jval_v(com));
		ptr = dll_first(list);
	}
}

/*
 * get_cost
 * parse cost
 */
void get_cost(Dllist list)
{
	Dllist ptr;
	Node *tmp;
	Cost *cost;

	//printf("-------------------get_cost-------------------\n");
	
	ptr = dll_first(list);
	dll_delete_node(ptr);

	/* allocate the struct for cost */
	Costlist = new_dllist();

	/* get the list of cost and sensor pair */
	ptr = dll_first(list);
	while (ptr != list) {
		tmp = (Node *) jval_v(dll_val(ptr));
		if (tmp->num > 0) {
			printf("At line %d, it should be a sensor type instead of cost\n", tmp->line);
			exit(1);
		} 
		if ((strcmp(tmp->s, "atomic") == 0) || (strcmp(tmp->s, "composite") == 0))
			break;
		if (invalid_sensor(tmp->s)) {
			printf("invalid sensor type: %s at line %d\n", tmp->s, tmp->line);
			exit(1);
		}
		cost = (Cost *) malloc(sizeof(Cost));
		cost->sensor = strdup(tmp->s);
		dll_delete_node(ptr);
		ptr = dll_first(list);
		if (ptr == list) {
			printf("The sensor %s doesn't have a cost\n", cost->sensor);
			exit(1);
		}
		tmp = (Node *) jval_v(dll_val(ptr));
		if (tmp->num < 0) {
			printf("At line %d, there should be a cost for the sensor\n", tmp->line); 
			exit(1);
		}
		cost->cost = tmp->num;
		dll_delete_node(ptr);
		ptr = dll_first(list);
		//printf("%s = %d\n", cost->sensor, cost->cost);
		dll_append(Costlist, new_jval_v(cost));
	}
}


/*
 * common sense configuration
 */
int common_cfg(IS is, int id)
{
	IS common;
	Dllist list, ptr;
	Node *tmp;
	int dummy;
  char fn[20];

	/* delete comment and some symbols */
	de_comment(is, id);

	/* read in from the new input file */
  sprintf(fn, "simple%d", id);
	common = new_inputstruct(fn);
	if (common == 0) {
		perror("common_cfg: simple");
		exit(1);
	}

	/* get a dllist from input */	
	list = get_list(common, &dummy);

	/* describe atomic behavior */
	ptr = dll_first(list);
	if (ptr == list) {
		perror("commonsense.cfg is empty\n");
		exit(1);
	}
	tmp = (Node *) jval_v(dll_val(ptr));	
	if (tmp->num > 0) {
		printf("8. Wrong format at line %d\n", tmp->line);
		exit(1);
	}
	while (!dll_empty(list)) {
		if (strcmp(tmp->s, "atomic") == 0)
			get_atomic(list);	
		else if (strcmp(tmp->s, "composite") == 0)
			get_composite(list);
		else if (strcmp(tmp->s, "cost") == 0)
			get_cost(list);
		else {
			printf("9. Wrong format at line %d in commonsense.cfg\n", tmp->line);
			exit(1);
		}
		ptr = dll_first(list);
		tmp = (Node *) jval_v(dll_val(ptr));	
	}
	return 1;
}


/***********************  Information processing  *********************/

Dllist getlist(IS robot)
{
  Dllist list;
  Node *n;
  int i, tmp;

  list = new_dllist();
  while (get_line(robot) >= 0) {
    for (i = 0; i < robot->NF; i++) {
      if (strcmp(robot->fields[i], "{") == 0 || strcmp(robot->fields[i], "}") == 0) continue;
      n = (Node *) malloc(sizeof(Node));
      n->line = robot->line;
      n->s = (char *)malloc(sizeof(char)*strlen(robot->fields[i]));
      n->s = strdup(robot->fields[i]);
      n->num = -1;

      if (strcmp(n->s, "need") != 0 && strcmp(n->s, "provide") != 0  && strcmp(n->s, "communicate") != 0 && strcmp(n->s, ">") != 0 && strcmp(n->s, "<") != 0 && strcmp(n->s, "&") != 0) {
        if (invalid_atomic(n->s)&&invalid_composite(n->s)&&invalid_info(n->s)) {
          printf("wrong type \"%s\" at line %d\n", n->s, n->line);
          exit(1);
        }
      }
      dll_append(list, new_jval_v((void *)n));
    }
  }
  return list;
}

/* 
 * allocate a new infonode
 */
Infonode *new_infonode()
{
    Infonode *info;

    info = (Infonode *) malloc(sizeof(Infonode));
    info->multinput = new_dllist();
    info->input = 0;
    info->output = 0;
    info->schema = new_dllist();
    return info;
}

/* 
 * get_need
 * to fill in Needlist
 */
void get_need(Dllist list)
{
    Dllist ptr, ptr1;
    Node *node;
    Infonode *info;
    char *tmp;
    int line = -1, extra = 0;
    int tt;

    /* allocate the data structure for need list */
    Needlist = new_dllist();

    ptr = dll_first(list);
    dll_delete_node(ptr);

    ptr = dll_first(list);
    while (ptr != list) {
        node = (Node *) jval_v(dll_val(ptr));
        if (strcmp(node->s, "provide") == 0 || (strcmp(node->s, "communicate") == 0)) {
            dll_append(Needlist, new_jval_v(info));
            break;
        }
        if (line == -1)
            info = new_infonode();
        if ((line != -1) && (line != node->line)) {
            dll_append(Needlist, new_jval_v(info));
            info = new_infonode();
            extra = 0;
        }
        if (!invalid_atomic(node->s) || !invalid_composite(node->s)) {
            line = node->line;
            dll_append(info->schema, new_jval_s(node->s));
        } else if (!invalid_info(node->s)) {
            if (extra == 1) {
                dll_append(info->multinput, new_jval_s(node->s));
                extra = 0;
            } else {
                info->input = strdup(node->s);
                dll_append(info->multinput, new_jval_s(node->s));
            }
            line = node->line;
        } else if (strcmp("&", node->s) == 0) {
            extra = 1;
            info->input = strdup("&");
        }

        dll_delete_node(ptr);
        ptr = dll_first(list);
    }
    //if (strcmp(node->s, "provide") != 0)
        //dll_append(Needlist, new_jval_v(info));
/*
    dll_traverse(ptr, Needlist) {
        info = (Infonode *) jval_v(dll_val(ptr));
        dll_traverse(ptr1, info->schema) {
            tmp = (char *) jval_s(dll_val(ptr1));
            printf("%s ", tmp);
        }
        printf("needs input:");
        dll_traverse(ptr1, info->multinput) {
            tmp = (char *) jval_s(dll_val(ptr1));
            printf("%s ", tmp);
        }
        printf("\n");   
    }
    printf("\n");
*/
}

void get_provide(Dllist list)
{
    Dllist ptr, ptr1;
    Node *node;
    Infonode *info = 0;
    char *tmp; 
    int line = -1;

    /* allocate the provider list */
    Provlist = new_dllist();

    ptr = dll_first(list);
    dll_delete_node(ptr);

    ptr = dll_first(list);
    while (ptr != list) {
        node = (Node *) jval_v(dll_val(ptr));
        if (strcmp(node->s, "&") == 0) {
            dll_delete_node(ptr);
            ptr = dll_first(list);
            continue;
        }   
        if (strcmp(node->s,"need")==0||(strcmp(node->s,"communicate")==0)) {
			      if (line != -1) 
            	dll_append(Provlist, new_jval_v(info));
            break;
        }   
        if (line == -1)
            info = new_infonode();
        if ((line != -1) && (line != node->line)) {
            dll_append(Provlist, new_jval_v(info));
            info = new_infonode();
        }
        if (!invalid_atomic(node->s) || !invalid_composite(node->s)) {
            line = node->line;
            dll_append(info->schema, new_jval_s(node->s));
        } else if (!invalid_info(node->s)) {
            info->output = strdup(node->s);
            line = node->line;
        }
        dll_delete_node(ptr);
        ptr = dll_first(list);
    }
    //if (strcmp(node->s, "need") != 0)
        //dll_append(Provlist, new_jval_v(info));
/*
    dll_traverse(ptr, Provlist) {
        info = (Infonode *) jval_v(dll_val(ptr));
        dll_traverse(ptr1, info->schema) {
            tmp = (char *) jval_s(dll_val(ptr1));
            printf("%s ", tmp);
        }
        printf("output %s\n", info->output);
    }
    printf("\n");
*/
}


void get_comm(Dllist list)
{
    Dllist ptr, ptr1;
    Node *node, *tmp;
    Infonode *info;
    char *prev = 0, *next = 0; /* information */
    int line = -1;

    /* allocate the data structure for communication list */
    Commlist = new_dllist();

    ptr = dll_first(list);
    dll_delete_node(ptr);

    ptr = dll_first(list);
    while (ptr != list) {
        node = (Node *) jval_v(dll_val(ptr));
        if ((strcmp(node->s, "provide") == 0) || (strcmp(node->s, "need") == 0)) {
            dll_append(Commlist, new_jval_v(info));
            break;
        }
        if (line == -1)
            info = new_infonode();
        if ((line != -1) && (line != node->line)) {
            dll_append(Commlist, new_jval_v(info));
            info = new_infonode();
            prev = 0;
            next = 0;
        }
        /*  if this field is information */
        if (!invalid_info(node->s)) {
            if (prev == 0) {
                ptr1 = dll_next(dll_first(list));
                if (ptr1 != list) {
                    tmp = (Node *) jval_v(dll_val(ptr1));
                    if (strcmp(tmp->s, "<") == 0) {
                        info->input = strdup(node->s);
                    } else if (strcmp(tmp->s, ">") == 0) {
                        info->output = strdup(node->s);
                    } else {
                        printf("10. Wrong format at line %d\n", tmp->line);
                    }
                }
            } else {
                ptr1 = dll_next(dll_first(list));
                if (ptr1 == list) next = 0;
                else {
                    tmp = (Node *) jval_v(dll_val(ptr1));
                    if (tmp->line != line) next = 0;
                    else next = strdup(tmp->s);
                }

                if (next == 0) {
                    if (strcmp(prev, ">") == 0)
                        info->output = strdup(node->s);
                    else if (strcmp(prev, "<") == 0)
                        info->input = strdup(node->s);
                }
            }
            line = node->line;
        } else if (!invalid_composite(node->s) || !invalid_atomic(node->s)) {
            dll_append(info->schema, new_jval_s(node->s));
            line = node->line;
        }

        prev = strdup(node->s);
        dll_delete_node(ptr);
        ptr = dll_first(list);
        if (ptr == list) dll_append(Commlist, new_jval_v(info));
    }
/*
    dll_traverse(ptr, Commlist) {
        info = (Infonode *) jval_v(dll_val(ptr));
        dll_traverse(ptr1, info->schema) {
            next = (char *) jval_s(dll_val(ptr1));
            printf("%s ", next);
        }
        if (info->input != 0)
            printf("input %s\n", info->input);
        if (info->output != 0)
            printf("output %s\n", info->output);
    }
    printf("\n");
*/
}

/*
 * info_cfg
 * information configuration
 */
void info_cfg(IS is, int id)
{
    IS info;
    Dllist list, ptr;
    Node *node;
    char *content, fn[20];
    int count;

    de_comment(is, id);
    sprintf(fn, "simple%d", id);
    info = new_inputstruct(fn);
    if (info == 0) {
        perror("info_cfg: info");
        exit(1);
    }
    list = new_dllist();
    list = (Dllist )getlist(info);

    ptr = dll_first(list);
    if (ptr == list) {
        perror("info.cfg is empty");
        exit(1);
    }
    node = (Node *) jval_v(dll_val(ptr));
    if (node->num > 0) {
        printf("11. Wrong format at line %d: %s %d\n", node->line, node->s, node->num);
        exit(1);
    }
    while (!dll_empty(list)) {
        if (strcmp(node->s, "need") == 0) get_need(list);
        else if (strcmp(node->s, "provide") == 0) get_provide(list);
		    else if (strcmp(node->s, "communicate") == 0) get_comm(list);
        else {
            printf("13. Wrong format at line %d in info.cfg\n", node->line);
            exit(1);
        }
        ptr = dll_first(list);
        node = (Node *) jval_v(dll_val(ptr));
    }
    printf("\n");
}

/*
 * get the nth element in the dllist dll
 */
Dllist get_ptr(Dllist dll, int n)
{   
    Dllist ptr;
    int i = 1;

    dll_traverse(ptr, dll) {
        if (i == n)
            return ptr;
        i++;
    }   
    return 0;
}

/*
 * who_can_provide
 * find out the information provider
 */
Dllist who_can_provide(char *info)
{
    Dllist provider, ptr, ptr1, ptr2;
    Infonode *in;
    char *tmp, *who = 0;

    provider = new_dllist();

    dll_traverse(ptr, Provlist) {
        in = (Infonode *) jval_v(dll_val(ptr));
        if (in->output == 0) continue;
        if (strcmp(info, in->output) == 0) {
            dll_traverse(ptr1, in->schema) {
                tmp = (char *) jval_s(dll_val(ptr1));
                if (who == 0) { 
                    who = (char *) malloc(sizeof(char) *30);
                    strcpy(who, tmp);
                } else {
                    strcat(who, " & ");
                    strcat(who, tmp);
                }
            }
        }
        if (who != 0) {
            //dll_append(provider, new_jval_s(who));
            my_append_s(provider, who); 
            who = 0;
        }
    }
    return provider;
}

/*
 * needs
 * does this schema depends on other input of information
 */
Dllist *allneeds(char *provider, int *nor)
{
    char *tmp;
    Dllist ptr, ptr1, ptr2;
    Infonode *in;
    Dllist *need;
    int i = 0, num = 0;

    dll_traverse(ptr, Needlist) {
        in = (Infonode *) jval_v(dll_val(ptr));
        dll_traverse(ptr1, in->schema) {
            tmp = (char *) jval_s(dll_val(ptr1));
            if (strcmp(provider, tmp) == 0)
                num++;
        }
    }

    need = (Dllist *) malloc(sizeof(Dllist)*num);
    for (i = 0; i < num; i++)
        need[i] = new_dllist();

    i = 0;
    dll_traverse(ptr, Needlist) {
        in = (Infonode *) jval_v(dll_val(ptr));
        dll_traverse(ptr1, in->schema) {
            tmp = (char *) jval_s(dll_val(ptr1));
            if (strcmp(provider, tmp) == 0) {
                //printf("\n%s needs: ", tmp);
                dll_traverse(ptr2, in->multinput) {
                    tmp = (char *) jval_s(dll_val(ptr2));
                    dll_append(need[i], new_jval_s(strdup(tmp)));
                    //printf("%s ", tmp);
                }
                i++;
            }
        }
    }
    *nor = num;

    if (num == 0)
        return 0;
    else return need;
}

/*
 * check whether the information needed can be transferred from others
 */
int in_commlist(char *inf)
{
  Dllist ptr;
  char *s; 
  Infonode *info;

  dll_traverse(ptr, Commlist) {
    info = (Infonode *) jval_v(dll_val(ptr));
    if (info->output != 0) {
      if (strcmp(info->output, inf) == 0) {
        //printf("output %s\n", info->output);
        return 1;
      }
    }
  }
  return 0;
}

/*
 * build the and-or-tree according to the current goal
 */
void build_and_or_tree(AO_node parent, Dllist infolist)
{
  Dllist ptr0, ptr1, ptr2, ptr3;
  Dllist prov_list;
  Infonode *infonode;
  AO_node node_info, node_prov, node_comm;
  char *info, *prov, tmp1[20], *tmp, *prevtmp = 0;
 
  dll_traverse(ptr0, infolist) {
    info = (char *) jval_s(dll_val(ptr0)); 
    node_info = (AO_node) new_ao_node(0, 1, info, parent);  
    ao_insert_child(parent, node_info);

    //* can this information type be provided through communication?
    if (in_commlist(node_info->name)) {//yes
      sprintf(tmp1, "cs & [cs & %s]", node_info->name);
      node_comm = (AO_node) new_ao_node(1, 0, tmp1, node_info);
      ao_insert_child(node_info, node_comm);
    }

    // who can provide this information type?
    //printf("who can provide %s\n", info);
    prov_list = who_can_provide(info); 
    if (dll_empty(prov_list)) continue;
  
    dll_traverse(ptr1, prov_list) {
      prov = (char *) jval_s(dll_val(ptr1)); 
      node_prov = (AO_node) new_ao_node(1, 0, prov, node_info); 
      ao_insert_child(node_info, node_prov); 

      // does this schema need other input information types?
      prevtmp = 0;
      dll_traverse(ptr2, Needlist) {
        infonode = (Infonode *) jval_v(dll_val(ptr2));
        tmp = (char *) jval_s(dll_val(dll_first(infonode->schema)));
        // is this the provider schema?
        if (strcmp(tmp, prov) == 0) {// yes, recursivley build the tree
          if (prevtmp == 0) prevtmp = strdup(tmp);
          else if (strcmp(prevtmp, tmp) == 0) {
            // it's an "OR" relationship
            // insert it as a new node to the parent 
            node_prov = (AO_node) new_ao_node(1, 0, tmp, node_info);
            ao_insert_child(node_info, node_prov);
          }
          prevtmp = strdup(tmp);
          build_and_or_tree(node_prov, infonode->multinput);
        }
      }
    }
  }
}

/*
 * generate number of ways associated with each information type
 */
int gen_num(AO_node head)
{
  Dllist ptr, ptr1;
  AO_node s_node, i_node;
  int tmpways = 1;

  if (head->type != 0) {
    printf("wrong type %s\n", head->name);
    exit(1);
  }
  // if this node has already been processed, ignore
  if (head->numways > 0) return head->numways;

  dll_traverse(ptr, head->children) {
    s_node = (AO_node) jval_v(dll_val(ptr));
    if (dll_empty(s_node->children)) {// no input requirement
      head->numways++; 
    } else {
      dll_traverse(ptr1, s_node->children) {
        i_node = (AO_node) jval_v(dll_val(ptr1));
        tmpways *= gen_num(i_node); 
      }
      head->numways += tmpways;
      tmpways = 1;
    }
  }
  return head->numways;
}


/*
 * generate the schema list associated with each information type
 */
void gen_schemalist(AO_node head, AO_node root_i)
{
  Dllist ptr, ptr1, ptr2, ptr3;
  Dllist *tmplist, *combinedlist;
  AO_node s_node, i_node, next_node, find_node;
  int i, j, k, curr_numways, index, numways = 1;
  char *tmp1, *tmp2;

  if (head->type != 0) {
    printf("wrong type %s\n", head->name);
    exit(1);
  }
  // if this node has already been processed, ignore
  if (head->processed) {
    //printf("%s has already been processed\n", head->name);
    return;
  }
  if ((find_node = (AO_node) ao_find_child(root_i, head->name)) != 0) {
    // already have a copy intialized?
    if (find_node->processed) {
      head->schemalist = find_node->schemalist;
      head->numways = find_node->numways;
      //printf("%s already had a copy in the tree\n", head->name);
      return;
    }
  }

  index = 0; // current index in the schemalist for head node
  dll_traverse(ptr, head->children) { // OR relathionship
    s_node = (AO_node) jval_v(dll_val(ptr));
    if (dll_empty(s_node->children)) {// no input requirement
      my_append_s(head->schemalist[index], s_node->name);
      index++;  
    } else { // AND relationship
      dll_traverse(ptr1, s_node->children) {
        i_node = (AO_node) jval_v(dll_val(ptr1));
        gen_schemalist(i_node, root_i);
      }

      numways = 1;
      dll_traverse(ptr1, s_node->children) {
        i_node = (AO_node) jval_v(dll_val(ptr1));
        numways *= i_node->numways;
      }
       
      // initialize tmplist
      tmplist = (Dllist *) malloc(sizeof(Dllist) * numways);
      for (i = 0; i < numways; i++) 
        tmplist[i] = new_dllist();

      // combine schemalist, AND relationship
      curr_numways = 0; // the index
      dll_traverse(ptr1, s_node->children) {
        i_node = (AO_node) jval_v(dll_val(ptr1));
        if (dll_empty(tmplist[0])) {// for the first time
          for (i = 0; i < i_node->numways; i++) {
            dll_traverse(ptr3, i_node->schemalist[i]) {
              tmp2 = (char *) jval_s(dll_val(ptr3));
              my_append_s(tmplist[i], tmp2);
            }
            curr_numways++;
          }
          continue;
        } 
        combinedlist = (Dllist *) malloc(sizeof(Dllist) * numways);
        for (i = 0; i < numways; i++)
          combinedlist[i] = new_dllist();

        // combine tmplist and the current schemalist to combinedlist 
        k = 0;
        for (i = 0; i < curr_numways; i++) {
          for (j = 0; j < i_node->numways; j++) {
            dll_traverse(ptr2, tmplist[i]) {
              tmp1 = (char *) jval_s(dll_val(ptr2));
              my_append_s(combinedlist[k], tmp1);
            }  
            dll_traverse(ptr3, i_node->schemalist[j]) {
              tmp2 = (char *) jval_s(dll_val(ptr3));
              my_append_s(combinedlist[k], tmp2);
            }
            k++;
          }
        }  
        // keep the current number of ways
        curr_numways = k;
        // clear tmplist 
        for (i = 0; i < numways; i++) tmplist[i] = new_dllist();
        // copy combinedlist to tmplist
        for (i = 0; i < curr_numways; i++) {
          dll_traverse(ptr2, combinedlist[i]) {
            tmp1 = (char *) jval_s(dll_val(ptr2));
            my_append_s(tmplist[i], tmp1);
          }
        }
        // clear combinedlist 
        for (i = 0; i < curr_numways; i++) combinedlist[i] = new_dllist();
      } // end of combination

      // copy tmplist to head->schemalist
      for (i = 0; i < curr_numways; i++) {
        my_append_s(tmplist[i], s_node->name);
        dll_traverse(ptr2, tmplist[i]) {
          tmp2 = (char *) jval_s(dll_val(ptr2));
          my_append_s(head->schemalist[index], tmp2);
        }
        index++;
      } 
    } // end of AND relationship
  }
  head->processed = 1; // now, processed
}


/*
 * generate rules for every type of input information
 */
void gen_info_schema(int root_i)
{
  int i, j, k;
  char *tmp;
  Dllist ptr;
  Dllist dummyinfo;
  AO_node node;

  dummynum = 0; // a global variable

  // initialize the and_or_tree
  for (i = 0; i < NI; i++) {
    node = (AO_node) ao_find_child(roots[root_i], INFO[i]);
    if (node != 0) {// if the node is in the tree
      gen_num(node);
      // initialize the schemalist in the and_or_tree
      if (node->schemalist == 0) {
        node->schemalist = (Dllist *) malloc (sizeof(Dllist)*node->numways);
        for (j = 0; j < node->numways; j++)
          node->schemalist[j] = new_dllist();
      }
    } else dummynum++; 
  }
  // generate the schemalist for information types not in the goal tree
  dummyroots = (AO_node *) malloc(sizeof(AO_node)*dummynum);
   
  // generate the schemalist for each information type
  k = 0; // index to the dummyroots schemalist
  for (i = 0; i < NI; i++) {
    node = (AO_node) ao_find_child(roots[root_i], INFO[i]); 
    //printf("--------------- %s -------------\n", node->name);
    if (node != 0) {// if the node is in the tree
      // generate the schemalist
      gen_schemalist(node, roots[root_i]);
      /*
      for (j = 0; j < node->numways; j++) {
        printf("%d: ", j+1);
        dll_traverse(ptr, node->schemalist[j]) {
          tmp = (char *) jval_s(dll_val(ptr));
          printf("%s ", tmp);
        }
        printf("\n");
      }*/
    } else {// if the node is not in the tree
      dummyroots[k] = (AO_node) new_ao_node(1, 0, "dummy", 0);
      dummyinfo = new_dllist();
      dll_append(dummyinfo, new_jval_s(INFO[i]));

      build_and_or_tree(dummyroots[k], dummyinfo);

      node = (AO_node) ao_find_child(dummyroots[k], INFO[i]);
      gen_num(node);
      if (node->numways == 0) {k++; continue;}
      if (node->schemalist == 0) { 
        node->schemalist = (Dllist *) malloc (sizeof(Dllist)*node->numways);
        for (j = 0; j < node->numways; j++)
          node->schemalist[j] = new_dllist();
      }
      // this is tricky
      gen_schemalist(node, roots[root_i]); 
      /*
      for (j = 0; j < node->numways; j++) {
        printf("%d: ", j+1);
        dll_traverse(ptr, node->schemalist[j]) {
          tmp = (char *) jval_s(dll_val(ptr));
          printf("%s ", tmp);
        }
        printf("\n");
      }*/
      k++;
    }
  }
}

/*
 * generate rules to be used in commonsense.cfg
 */
void generate_rules()
{
  Dllist ptr, ptr1;
  Infonode *info;
  char *tmp;
  int i;

  // find the number of ways that can accomplish goal
  numroot = 0;
  dll_traverse(ptr, Needlist) {
    info = (Infonode *) jval_v(dll_val(ptr));
    dll_traverse(ptr1, info->schema) {
      tmp = (char *) jval_s(dll_val(ptr1));
      if (strcmp(tmp, goal) == 0) {
        numroot++;
      }
    }
  }
  roots = (AO_node *) malloc(sizeof(AO_node)*numroot);

  // find the information needed to accomplish goal 
  i = 0;
  dll_traverse(ptr, Needlist) {
    info = (Infonode *) jval_v(dll_val(ptr));
    dll_traverse(ptr1, info->schema) {
      tmp = (char *) jval_s(dll_val(ptr1));
      if (strcmp(tmp, goal) == 0) {
        roots[i] = (AO_node) new_ao_node(1, 0, goal, 0);         
        build_and_or_tree(roots[i], info->multinput);
        //ao_printtree(roots[i]);
        gen_info_schema(i);   
        i++;
      }
    }
  }
  return;
}

/*
 * combine schemalists, AND relationship, return the
   number of solutions so far
 */
int combine_list(AO_node head, int numways, FILE *f)
{
  AO_node i_node;
  Dllist ptr1, ptr2, ptr3;
  Dllist *tmplist, *combinedlist, *checkedlist;
  char *tmp1, *tmp2, *tmp3 = 0, *tmp4 = 0;
  int i, j, k, curr_numways, len1, len2, find = 0;
  //static myindex = 0; // the index in the pslist array

  // initialize tmplist
  tmplist = (Dllist *) malloc(sizeof(Dllist) * numways);
  for (i = 0; i < numways; i++)
    tmplist[i] = new_dllist();

  // combine schemalist, AND relationship
  curr_numways = 0; // the index
  dll_traverse(ptr1, head->children) {
    i_node = (AO_node) jval_v(dll_val(ptr1));
    if (dll_empty(tmplist[0])) {// for the first time
      for (i = 0; i < i_node->numways; i++) {
        dll_traverse(ptr3, i_node->schemalist[i]) {
          tmp2 = (char *) jval_s(dll_val(ptr3));
          my_append_s(tmplist[i], tmp2);
        }
        curr_numways++;
      }
      continue;
    }
    // clear combinedlist
    combinedlist = (Dllist *) malloc(sizeof(Dllist) * numways);
    for (i = 0; i < numways; i++)
      combinedlist[i] = new_dllist();

    // combine tmplist and the current schemalist to combinedlist
    k = 0;
    for (i = 0; i < curr_numways; i++) {
      for (j = 0; j < i_node->numways; j++) {
        dll_traverse(ptr2, tmplist[i]) {
          tmp1 = (char *) jval_s(dll_val(ptr2));
          my_append_s(combinedlist[k], tmp1);
        }
        dll_traverse(ptr3, i_node->schemalist[j]) {
          tmp2 = (char *) jval_s(dll_val(ptr3));
          my_append_s(combinedlist[k], tmp2);
        }
        k++;
      }
    }
    // keep the current number of ways
    curr_numways = k;
    // clear tmplist
    for (i = 0; i < numways; i++) tmplist[i] = new_dllist();
    // copy combinedlist to tmplist
    for (i = 0; i < curr_numways; i++) {
      dll_traverse(ptr2, combinedlist[i]) {
        tmp1 = (char *) jval_s(dll_val(ptr2));
        my_append_s(tmplist[i], tmp1);
      }
    }
  } // end of combination

  // clean the combinedlist, make sure that there are no iterated solutions
  // 1. order the solutions
  checkedlist = (Dllist *) malloc(sizeof(Dllist)*numways);
  for (i = 0; i < numways; i++) {
    checkedlist[i] = new_dllist();
    
    dll_traverse(ptr1, combinedlist[i]) {
      tmp1 = (char *) jval_s(dll_val(ptr1));
      if (dll_empty(checkedlist[i])) {
        dll_append(checkedlist[i], new_jval_s(strdup(tmp1)));
      } else {
        dll_traverse(ptr2, checkedlist[i]) {
          tmp2 = (char *) jval_s(dll_val(ptr2));
          if (strcmp(tmp1, tmp2) > 0) { 
            if (ptr2 == dll_last(checkedlist[i])) // insert after
              dll_insert_a(ptr2, new_jval_s(strdup(tmp1)));
            continue;
          } else if (strcmp(tmp1, tmp2) < 0) {// insert before
            dll_insert_b(ptr2, new_jval_s(strdup(tmp1))); 
            break;
          } 
        }
      }
    }
  }
  // 2. delete iterated solutions
  for (i = 0; i < numways; i++) {
    if (myindex == 0) { // first time
      dll_traverse(ptr1, checkedlist[i]) {
        tmp1 = (char *) jval_s(dll_val(ptr1));
        dll_append(local->pslist[myindex], new_jval_s(strdup(tmp1)));
      } 
      myindex++;
      continue;
    }
    find = 0;
    for (j = 0; j < myindex; j++) {  
      // compare pslist[j] with checkedlist[i]
      len1 = 1;
      dll_traverse(ptr1, local->pslist[j]) {
        tmp1 = (char *) jval_s(dll_val(ptr1));
        len1 += strlen(tmp1);
      }
      tmp3 = (char *) calloc(sizeof(char), len1);
      dll_traverse(ptr1, local->pslist[j]) {
        tmp1 = (char *) jval_s(dll_val(ptr1));
        strcat(tmp3, tmp1);
      }
      strcat(tmp3, "\0");

      len2 = 1;
      dll_traverse(ptr2, checkedlist[i]) {
        tmp2 = (char *) jval_s(dll_val(ptr2));
        len2 += strlen(tmp2);
      } 
      tmp4 = (char *) calloc(sizeof(char), len2);
      dll_traverse(ptr2, checkedlist[i]) {
        tmp2 = (char *) jval_s(dll_val(ptr2));
        strcat(tmp4, tmp2);
      } 
      strcat(tmp4, "\0");
      //printf("compare (%s) with (%s)\n", tmp3, tmp4);
      if (strcmp(tmp3, tmp4) == 0) { // same solution, ignore
        find = 1; break; 
      } 
    }
    if (!find) {
      dll_traverse(ptr1, checkedlist[i]) {
        tmp1 = (char *) jval_s(dll_val(ptr1));
        dll_append(local->pslist[myindex], new_jval_s(strdup(tmp1)));
      }
      myindex++;
    } 
  }
  return myindex;
}

/*
 * write_rules
 * write rules to commonsense.cfg
 */
void write_rules(int id, int type)
{
  FILE *f;
  char *tmp, fn[20], tmpfn[20];
  Dllist ptr;
  int i;
  IS is;

	sprintf(fn, "../config/commonsense%d.cfg", type);
  is = new_inputstruct(fn);
  sprintf(tmpfn, "../config/tmpcs%d.cfg", id);
 	f = fopen(tmpfn, "w");
  if (f == 0) {
    perror("cannot open tmpcs.cfg to write");
    exit(1);
  }

  while(get_line(is) >= 0) fprintf(f, "%s", is->text1);

  // write rules into commonsense.cfg
  fprintf(f, "\ncomposite {\n");
  fprintf(f, "1, \n");
  fprintf(f, "%s = %d, \n", goal, maxway);

  for (i = 0; i < maxway; i++) {
    dll_traverse(ptr, local->pslist[i]) {
      tmp = (char *) jval_s(dll_val(ptr));
      if (ptr != dll_last(local->pslist[i]))
        fprintf(f, "%s & ", tmp);
      else if (i != maxway-1)
        fprintf(f, "%s |\n", tmp);
      else fprintf(f, "%s\n}\n", tmp);
    }
  }
  fclose(f);
}

// process information types 
void infoproc(int opt, int id, int type)
{
  IS info;
	char fn[20];
  AO_node i_node;
  Dllist ptr;
  int i, numways = 1, totalways = 0; 

	sprintf(fn, "../config/info%d.cfg", type);
 	info = new_inputstruct(fn);
  if (info == 0) {
    perror("info.cfg");
    exit(1);
  }

  info_cfg(info, id);

  generate_rules();

  for (i = 0; i < numroot; i++) {
    dll_traverse(ptr, roots[i]->children) {
      i_node = (AO_node) jval_v(dll_val(ptr));
      numways *= i_node->numways;
    }
    roots[i]->numways = numways;
    totalways += numways;
    numways = 1;
  }
  // initialize local robot's potential solution list
  local->pslist = (Dllist *) malloc(sizeof(Dllist)*totalways);
  for (i = 0; i < totalways; i++)
    local->pslist[i] = new_dllist();

  // combine the schemalist for each required information type
  for (i = 0; i < numroot; i++)
    maxway = combine_list(roots[i], roots[i]->numways, f);

  // initialize hashway list
  hashway = (Dllist *) malloc(sizeof(Dllist)*maxway);
  for (i = 0; i < maxway; i++) hashway[i] = new_dllist();

  if (opt == 1) write_rules(id, type);

  jettison_inputstruct(info);
}
 
void gen_info()
{
  int besti, i, j, k, fail = 0, find = 0;
  char *tmp, *dummy;
  Dllist ptr;
  AO_node node;
  Infonode *info;
  float utility = 0, totalu = 0, bestu = 0;

  for (i = 0; i < NI; i++) {
    for (k = 0; k < numroot; k++) {
      node  = (AO_node) ao_find_child(roots[k], INFO[i]);
      if (node  == 0) {
        for (j = 0; j < dummynum; j++) {
          node = (AO_node) ao_find_child(dummyroots[j], INFO[i]);
          if (node != 0) break;
        }
        if (node != 0) {find = 1; break;}
      } else {find = 1; break;}
    } 
    if (!find) continue; 
    else find = 0;
    for (j = 0; j < node->numways; j++) {
      dll_traverse(ptr, node->schemalist[j]) {
        tmp = (char *) jval_s(dll_val(ptr));
        if (!capableof(tmp)) {
          fail = 1;
          break;
        }
      }
      if (fail == 0) { // if found
        //printf("%s --> \n%d: ", INFO[i], j+1);
        dll_traverse(ptr, node->schemalist[j]) {
          tmp = (char *) jval_s(dll_val(ptr));
          //printf("%s ", tmp);
          single_cost(tmp, &dummy, &utility);
          totalu += utility; 
        }
        //printf("\n");
        if (bestu == 0) {
          bestu = totalu;
          besti = j;
        } else {
          if (totalu < bestu) {// record the 
            bestu = totalu;
            besti = j;
          }
        }
        totalu = 0;
      } else fail = 0;
    }
    if (bestu > 0) {
      //printf("\nappend info %s to local robot\n", INFO[i]);
      //printf("best utility: index: %d, %f \n", besti, bestu);
      // generate a new info node
      info = (Infonode *) malloc(sizeof(Infonode));
      info->name = strdup(INFO[i]);
      info->schema = new_dllist();
      info->utility = bestu;
      dll_traverse(ptr, node->schemalist[besti]) {
        tmp = (char *) jval_s(dll_val(ptr));
        dll_append(info->schema, new_jval_s(strdup(tmp)));
      }
      dll_append(local->infolist, new_jval_v(info));
    }
    bestu = 0;
  } 
}
